<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket æµ‹è¯•å·¥å…· - Protobufè°ƒè¯•ç‰ˆ</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
        }
        .status-indicator.connected {
            background: #28a745;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
        }
        .control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-weight: bold;
            color: #555;
            font-size: 14px;
        }
        input, textarea, select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        input:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .btn-warning {
            background: #ffc107;
            color: #333;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .message-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .message-box {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            height: 400px;
            overflow-y: auto;
        }
        .message-box h3 {
            margin-top: 0;
            color: #555;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        .message {
            padding: 10px;
            margin: 8px 0;
            border-radius: 5px;
            font-size: 13px;
            word-break: break-all;
        }
        .message.sent {
            background: #e3f2fd;
            border-left: 3px solid #2196f3;
        }
        .message.received {
            background: #f1f8e9;
            border-left: 3px solid #8bc34a;
        }
        .message.error {
            background: #ffebee;
            border-left: 3px solid #f44336;
        }
        .message .timestamp {
            color: #999;
            font-size: 11px;
            margin-right: 10px;
        }
        .message .content {
            color: #333;
        }
        .message .proto-fields {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255,255,255,0.8);
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        .proto-field {
            margin: 4px 0;
            padding: 2px 0;
        }
        .proto-field .field-name {
            color: #2196f3;
            font-weight: bold;
        }
        .proto-field .field-value {
            color: #4caf50;
        }
        .proto-field .field-type {
            color: #999;
            font-size: 11px;
        }
        .quick-actions {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .quick-actions h3 {
            margin-top: 0;
            color: #555;
        }
        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .action-btn {
            padding: 8px 15px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .action-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        .stats {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }
        .stat-item {
            flex: 1;
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        .stat-label {
            font-size: 12px;
            color: #999;
        }
        .hex-dump {
            font-family: monospace;
            font-size: 11px;
            color: #666;
            margin-top: 5px;
            padding: 5px;
            background: #f5f5f5;
            border-radius: 3px;
            word-break: break-all;
        }
        .nested-object {
            margin-left: 20px;
            padding-left: 10px;
            border-left: 2px solid #e0e0e0;
        }
        .array-item {
            margin: 5px 0;
            padding: 5px;
            background: rgba(0,0,0,0.02);
            border-radius: 3px;
        }
        .debug-info {
            margin-top: 10px;
            padding: 10px;
            background: #fffbf0;
            border: 1px solid #ffa500;
            border-radius: 4px;
            font-size: 11px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ® è€è™æœºæ¸¸æˆ WebSocket æµ‹è¯•å·¥å…· - Protobufè°ƒè¯•ç‰ˆ</h1>
        
        <div class="status-bar">
            <div class="status">
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="statusText">æœªè¿æ¥</span>
            </div>
            <div id="connectionTime"></div>
        </div>

        <div class="control-panel">
            <div class="input-group">
                <label>WebSocket URL</label>
                <input type="text" id="wsUrl" value="ws://localhost:8080/ws/slot" placeholder="ws://localhost:8080/ws/slot">
            </div>
            <div class="input-group">
                <label>è°ƒè¯•æ¨¡å¼</label>
                <select id="debugMode">
                    <option value="readable">äººç±»å¯è¯»ï¼ˆæ¨èï¼‰</option>
                    <option value="hex">åå…­è¿›åˆ¶</option>
                    <option value="both">ä¸¤è€…éƒ½æ˜¾ç¤º</option>
                </select>
            </div>
        </div>

        <div class="button-group">
            <button id="connectBtn" class="btn-primary" onclick="connect()">è¿æ¥</button>
            <button id="disconnectBtn" class="btn-danger" onclick="disconnect()" disabled>æ–­å¼€</button>
            <button class="btn-warning" onclick="clearLogs()">æ¸…ç©ºæ—¥å¿—</button>
        </div>

        <div class="quick-actions">
            <h3>å¿«é€Ÿæµ‹è¯•å‘½ä»¤</h3>
            <div class="action-buttons">
                <div class="action-btn" onclick="sendEnterRoom()">è¿›å…¥æˆ¿é—´ (1901)</div>
                <div class="action-btn" onclick="sendStartGame(100)">å¼€å§‹æ¸¸æˆ (1902) - 100å¸</div>
                <div class="action-btn" onclick="sendStartGame(200)">å¼€å§‹æ¸¸æˆ (1902) - 200å¸</div>
                <div class="action-btn" onclick="sendStartGame(500)">å¼€å§‹æ¸¸æˆ (1902) - 500å¸</div>
            </div>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="sentCount">0</div>
                <div class="stat-label">å‘é€æ¶ˆæ¯</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="receivedCount">0</div>
                <div class="stat-label">æ¥æ”¶æ¶ˆæ¯</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="errorCount">0</div>
                <div class="stat-label">é”™è¯¯</div>
            </div>
        </div>

        <div class="message-area">
            <div class="message-box">
                <h3>ğŸ“¤ å‘é€çš„æ¶ˆæ¯</h3>
                <div id="sentMessages"></div>
            </div>
            <div class="message-box">
                <h3>ğŸ“¥ æ¥æ”¶çš„æ¶ˆæ¯</h3>
                <div id="receivedMessages"></div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let connectionStartTime = null;
        let sentCount = 0;
        let receivedCount = 0;
        let errorCount = 0;
        let debugMode = 'readable';

        // Protobuf wire types
        const WIRE_TYPES = {
            VARINT: 0,
            FIXED64: 1,
            LENGTH_DELIMITED: 2,
            FIXED32: 5
        };

        // å­—æ®µåç§°æ˜ å°„
        const FIELD_NAMES = {
            1901: { // m_1901_toc
                1: 'bet_val (ä¸‹æ³¨æ¡£ä½)',
                2: 'odds (èµ”ç‡ä¿¡æ¯)'
            },
            1902: { // m_1902_toc
                1: 'bet_val (ä¸‹æ³¨é‡‘é¢)',
                2: 'win (æœ¬æ¬¡èµ¢å–)',
                3: 'total_win (æ€»èµ¢å–)',
                4: 'is_free (æ˜¯å¦å…è´¹æ¸¸æˆ)',
                5: 'current_free (å½“å‰å…è´¹æ¸¸æˆ)',
                6: 'total_free (æ€»å…è´¹æ¸¸æˆ)',
                7: 'result (æ¸¸æˆç»“æœ)'
            },
            1903: { // p_1903_toc
                1: 'coins (å½“å‰é‡‘å¸)',
                2: 'remain (ä½™åˆ†)',
                3: 'down_coins (è½å¸)',
                4: 'jp1 (JP1å¥–æ± )',
                5: 'jp2 (JP2å¥–æ± )',
                6: 'jp3 (JP3å¥–æ± )',
                7: 'jp_all (æ€»å¥–æ± )'
            }
        };

        // ç¬¦å·æ˜ å°„
        const SYMBOL_NAMES = {
            0: 'å‘è´¢',
            1: 'çº¢ä¸­',
            2: 'ç™½æ¿',
            3: 'å…«ä¸‡',
            4: 'å…­ç­’',
            5: 'å…­æ¡',
            6: 'ä¸‰ç­’',
            7: 'äºŒæ¡',
            '-1': 'Wild',
            '999': 'Wild'
        };

        function updateStats() {
            document.getElementById('sentCount').textContent = sentCount;
            document.getElementById('receivedCount').textContent = receivedCount;
            document.getElementById('errorCount').textContent = errorCount;
        }

        function updateConnectionTime() {
            if (connectionStartTime) {
                const elapsed = Math.floor((Date.now() - connectionStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('connectionTime').textContent = 
                    `è¿æ¥æ—¶é•¿: ${minutes}åˆ†${seconds}ç§’`;
            } else {
                document.getElementById('connectionTime').textContent = '';
            }
        }

        setInterval(updateConnectionTime, 1000);

        // Protobufè§£æå™¨
        class ProtobufParser {
            constructor(bytes) {
                this.bytes = bytes;
                this.offset = 0;
            }

            readVarint() {
                let value = 0;
                let shift = 0;
                while (this.offset < this.bytes.length) {
                    const byte = this.bytes[this.offset++];
                    value |= (byte & 0x7F) << shift;
                    if ((byte & 0x80) === 0) {
                        return value;
                    }
                    shift += 7;
                }
                throw new Error('Varint too long');
            }

            readFixed32() {
                if (this.offset + 4 > this.bytes.length) {
                    throw new Error('Not enough bytes for fixed32');
                }
                const view = new DataView(this.bytes.buffer, this.bytes.byteOffset + this.offset, 4);
                this.offset += 4;
                return view.getUint32(0, true); // little-endian
            }

            readFixed64() {
                if (this.offset + 8 > this.bytes.length) {
                    throw new Error('Not enough bytes for fixed64');
                }
                const view = new DataView(this.bytes.buffer, this.bytes.byteOffset + this.offset, 8);
                this.offset += 8;
                // è¿”å›ä½32ä½ï¼Œå¯¹äºæˆ‘ä»¬çš„ç”¨ä¾‹è¶³å¤Ÿäº†
                return view.getUint32(0, true);
            }

            readBytes(length) {
                if (this.offset + length > this.bytes.length) {
                    throw new Error('Not enough bytes');
                }
                const result = this.bytes.slice(this.offset, this.offset + length);
                this.offset += length;
                return result;
            }

            parseMessage() {
                const fields = {};
                
                while (this.offset < this.bytes.length) {
                    const tag = this.readVarint();
                    const fieldNumber = tag >>> 3;
                    const wireType = tag & 0x07;
                    
                    let value;
                    switch (wireType) {
                        case WIRE_TYPES.VARINT:
                            value = this.readVarint();
                            break;
                        case WIRE_TYPES.FIXED64:
                            value = this.readFixed64();
                            break;
                        case WIRE_TYPES.LENGTH_DELIMITED:
                            const length = this.readVarint();
                            const bytes = this.readBytes(length);
                            // å°è¯•é€’å½’è§£æåµŒå¥—æ¶ˆæ¯
                            try {
                                const parser = new ProtobufParser(bytes);
                                value = parser.parseMessage();
                            } catch (e) {
                                // å¦‚æœä¸æ˜¯æ¶ˆæ¯ï¼Œå¯èƒ½æ˜¯å­—ç¬¦ä¸²æˆ–åŸå§‹å­—èŠ‚
                                value = bytes;
                            }
                            break;
                        case WIRE_TYPES.FIXED32:
                            value = this.readFixed32();
                            break;
                        default:
                            throw new Error(`Unknown wire type: ${wireType}`);
                    }
                    
                    // æ”¯æŒé‡å¤å­—æ®µ
                    if (fields[fieldNumber]) {
                        if (Array.isArray(fields[fieldNumber])) {
                            fields[fieldNumber].push(value);
                        } else {
                            fields[fieldNumber] = [fields[fieldNumber], value];
                        }
                    } else {
                        fields[fieldNumber] = value;
                    }
                }
                
                return fields;
            }
        }

        // æ ¼å¼åŒ–Protobufå­—æ®µä¸ºäººç±»å¯è¯»
        function formatProtobufFields(msgId, fields, indent = '') {
            const fieldNames = FIELD_NAMES[msgId] || {};
            let html = '';
            
            for (const [fieldNum, value] of Object.entries(fields)) {
                const fieldName = fieldNames[fieldNum] || `field_${fieldNum}`;
                
                if (value instanceof Uint8Array) {
                    // å­—èŠ‚æ•°ç»„ï¼Œå¯èƒ½æ˜¯åµŒå¥—æ¶ˆæ¯
                    try {
                        const parser = new ProtobufParser(value);
                        const nestedFields = parser.parseMessage();
                        html += `<div class="proto-field">
                            ${indent}<span class="field-name">${fieldName}</span>: 
                            <span class="field-type">[åµŒå¥—æ¶ˆæ¯]</span>
                            <div class="nested-object">
                                ${formatNestedObject(nestedFields, indent + '  ')}
                            </div>
                        </div>`;
                    } catch (e) {
                        // ä¸æ˜¯æ¶ˆæ¯ï¼Œæ˜¾ç¤ºä¸ºåå…­è¿›åˆ¶
                        const hex = Array.from(value).map(b => b.toString(16).padStart(2, '0')).join(' ');
                        html += `<div class="proto-field">
                            ${indent}<span class="field-name">${fieldName}</span>: 
                            <span class="field-value">${hex}</span>
                            <span class="field-type">[bytes]</span>
                        </div>`;
                    }
                } else if (typeof value === 'object' && !Array.isArray(value)) {
                    // åµŒå¥—å¯¹è±¡
                    html += `<div class="proto-field">
                        ${indent}<span class="field-name">${fieldName}</span>: 
                        <div class="nested-object">
                            ${formatNestedObject(value, indent + '  ')}
                        </div>
                    </div>`;
                } else if (Array.isArray(value)) {
                    // æ•°ç»„å­—æ®µ
                    html += `<div class="proto-field">
                        ${indent}<span class="field-name">${fieldName}</span>: 
                        <span class="field-type">[æ•°ç»„]</span>`;
                    value.forEach((item, idx) => {
                        html += `<div class="array-item">
                            ${indent}  [${idx}]: <span class="field-value">${formatValue(item)}</span>
                        </div>`;
                    });
                    html += '</div>';
                } else {
                    // ç®€å•å€¼
                    html += `<div class="proto-field">
                        ${indent}<span class="field-name">${fieldName}</span>: 
                        <span class="field-value">${formatValue(value)}</span>
                    </div>`;
                }
            }
            
            return html;
        }

        // æ ¼å¼åŒ–åµŒå¥—å¯¹è±¡
        function formatNestedObject(obj, indent = '') {
            let html = '';
            for (const [key, value] of Object.entries(obj)) {
                if (typeof value === 'object' && !Array.isArray(value) && !(value instanceof Uint8Array)) {
                    html += `<div class="proto-field">
                        ${indent}field_${key}: 
                        <div class="nested-object">
                            ${formatNestedObject(value, indent + '  ')}
                        </div>
                    </div>`;
                } else if (Array.isArray(value)) {
                    html += `<div class="proto-field">
                        ${indent}field_${key}: [æ•°ç»„]`;
                    value.forEach((item, idx) => {
                        const displayValue = formatValue(item);
                        html += `<div class="array-item">
                            ${indent}  [${idx}]: ${displayValue}
                        </div>`;
                    });
                    html += '</div>';
                } else {
                    html += `<div class="proto-field">
                        ${indent}field_${key}: <span class="field-value">${formatValue(value)}</span>
                    </div>`;
                }
            }
            return html;
        }

        // æ ¼å¼åŒ–å€¼
        function formatValue(value) {
            if (value instanceof Uint8Array) {
                return '[' + Array.from(value).join(', ') + ']';
            } else if (typeof value === 'number') {
                // æ£€æŸ¥æ˜¯å¦æ˜¯ç¬¦å·ID
                const symbolName = SYMBOL_NAMES[value];
                if (symbolName) {
                    return `${value} (${symbolName})`;
                }
                return value.toString();
            } else if (typeof value === 'boolean') {
                return value ? 'true' : 'false';
            } else {
                return JSON.stringify(value);
            }
        }

        // è§£ç å®Œæ•´çš„Protobufæ¶ˆæ¯
        function decodeProtobufMessage(bytes) {
            if (bytes.length < 6) {
                return { 
                    msgId: 0, 
                    length: 0, 
                    html: '<span style="color: red;">æ¶ˆæ¯å¤ªçŸ­ï¼Œæ— æ³•è§£æ</span>',
                    hex: ''
                };
            }
            
            const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
            
            // è¯»å–é•¿åº¦ï¼ˆ4å­—èŠ‚ï¼‰
            const length = view.getUint32(0, false);
            
            // è¯»å–æ¶ˆæ¯IDï¼ˆ2å­—èŠ‚ï¼‰
            const msgId = view.getUint16(4, false);
            
            // è·å–æ•°æ®éƒ¨åˆ†
            const dataBytes = bytes.slice(6);
            
            // ç”Ÿæˆåå…­è¿›åˆ¶æ˜¾ç¤º
            const hex = Array.from(dataBytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
            
            // è§£æProtobufæ•°æ®
            let html = `<div><strong>æ¶ˆæ¯ID:</strong> ${msgId}</div>`;
            html += `<div><strong>æ•°æ®é•¿åº¦:</strong> ${length} bytes</div>`;
            
            if (dataBytes.length > 0) {
                try {
                    const parser = new ProtobufParser(dataBytes);
                    const fields = parser.parseMessage();
                    
                    html += '<div class="proto-fields">';
                    html += '<div><strong>è§£æçš„å­—æ®µ:</strong></div>';
                    html += formatProtobufFields(msgId, fields);
                    html += '</div>';
                    
                    // ç‰¹æ®Šå¤„ç†æŸäº›æ¶ˆæ¯ç±»å‹
                    if (msgId === 1902 && fields[7]) {
                        // æ¸¸æˆç»“æœæ¶ˆæ¯ï¼Œè§£æresultå­—æ®µ
                        html += '<div class="debug-info">';
                        html += '<strong>æ¸¸æˆç»“æœè¯¦æƒ…:</strong><br>';
                        html += parseGameResult(fields[7]);
                        html += '</div>';
                    }
                } catch (e) {
                    html += `<div style="color: orange;">è§£æé”™è¯¯: ${e.message}</div>`;
                }
            } else {
                html += '<div>æ— æ•°æ®å†…å®¹</div>';
            }
            
            return {
                msgId: msgId,
                length: length,
                html: html,
                hex: hex
            };
        }

        // è§£ææ¸¸æˆç»“æœ
        function parseGameResult(resultData) {
            let html = '';
            
            try {
                if (resultData instanceof Uint8Array) {
                    const parser = new ProtobufParser(resultData);
                    const result = parser.parseMessage();
                    
                    // è§£æ5è¡Œæ•°æ®
                    for (let i = 1; i <= 5; i++) {
                        if (result[i]) {
                            html += `<div>ç¬¬${i}è¡Œ: `;
                            if (Array.isArray(result[i])) {
                                html += result[i].map(v => {
                                    const symbolName = SYMBOL_NAMES[v] || `ç¬¦å·${v}`;
                                    return symbolName;
                                }).join(', ');
                            }
                            html += '</div>';
                        }
                    }
                    
                    // è§£æå¥–åŠ±ä¿¡æ¯
                    if (result[6]) {
                        html += '<div>å¥–åŠ±ä¿¡æ¯: [åŒ…å«å¥–åŠ±æ•°æ®]</div>';
                    }
                } else if (typeof resultData === 'object') {
                    html += '<pre>' + JSON.stringify(resultData, null, 2) + '</pre>';
                }
            } catch (e) {
                html += `è§£æå¤±è´¥: ${e.message}`;
            }
            
            return html;
        }

        function connect() {
            const url = document.getElementById('wsUrl').value;
            debugMode = document.getElementById('debugMode').value;
            
            if (!url) {
                alert('è¯·è¾“å…¥ WebSocket URL');
                return;
            }

            try {
                ws = new WebSocket(url);
                ws.binaryType = 'arraybuffer'; // é‡è¦ï¼šè®¾ç½®äºŒè¿›åˆ¶ç±»å‹
                
                ws.onopen = function(event) {
                    console.log('WebSocket è¿æ¥å·²å»ºç«‹', event);
                    connectionStartTime = Date.now();
                    updateStatus(true);
                    addReceivedMessage('âœ… è¿æ¥æˆåŠŸ', 'success');
                };
                
                ws.onmessage = function(event) {
                    receivedCount++;
                    updateStats();
                    
                    if (event.data instanceof ArrayBuffer) {
                        const bytes = new Uint8Array(event.data);
                        const decoded = decodeProtobufMessage(bytes);
                        console.log('æ”¶åˆ°Protobufæ¶ˆæ¯:', decoded);
                        
                        let displayHtml = `<strong>[Protobuf æ¶ˆæ¯ ${decoded.msgId}]</strong><br>`;
                        
                        if (debugMode === 'readable' || debugMode === 'both') {
                            displayHtml += decoded.html;
                        }
                        
                        if (debugMode === 'hex' || debugMode === 'both') {
                            displayHtml += `<div class="hex-dump">HEX: ${decoded.hex}</div>`;
                        }
                        
                        addReceivedMessage(displayHtml, 'received', true);
                    } else {
                        // å¤„ç†æ–‡æœ¬æ¶ˆæ¯
                        console.log('æ”¶åˆ°æ–‡æœ¬æ¶ˆæ¯:', event.data);
                        addReceivedMessage(event.data);
                    }
                };
                
                ws.onerror = function(event) {
                    console.error('WebSocket é”™è¯¯:', event);
                    errorCount++;
                    updateStats();
                    addReceivedMessage('âŒ è¿æ¥é”™è¯¯', 'error');
                };
                
                ws.onclose = function(event) {
                    console.log('WebSocket è¿æ¥å·²å…³é—­', event);
                    connectionStartTime = null;
                    updateStatus(false);
                    addReceivedMessage(`âš ï¸ è¿æ¥å…³é—­ (code: ${event.code}, reason: ${event.reason || 'æ— '})`, 'error');
                };
                
            } catch (error) {
                console.error('åˆ›å»º WebSocket å¤±è´¥:', error);
                alert('åˆ›å»º WebSocket å¤±è´¥: ' + error.message);
            }
        }

        function disconnect() {
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        // ç¼–ç Protobufæ¶ˆæ¯
        function encodeProtobufMessage(msgId, data = {}) {
            let protoData = new Uint8Array(0);
            
            if (msgId === 1901) {
                // m_1901_tos: è¿›å…¥æˆ¿é—´ï¼Œtype = 1 (éº»å°†)
                protoData = new Uint8Array([0x08, 0x01]); // field 1, varint 1
            } else if (msgId === 1902) {
                // m_1902_tos: å¼€å§‹æ¸¸æˆï¼Œbet_val = data.betAmount
                const betAmount = data.betAmount || 100;
                const betBytes = encodeVarint(betAmount);
                protoData = new Uint8Array([0x08, ...betBytes]);
            }
            
            // è®¡ç®—æ€»é•¿åº¦ï¼ˆ2å­—èŠ‚æ¶ˆæ¯ID + protobufæ•°æ®ï¼‰
            const totalLength = 2 + protoData.length;
            
            // åˆ›å»ºå®Œæ•´çš„æ¶ˆæ¯ç¼“å†²åŒº
            const buffer = new ArrayBuffer(4 + totalLength);
            const view = new DataView(buffer);
            const bytes = new Uint8Array(buffer);
            
            // å†™å…¥é•¿åº¦ï¼ˆ4å­—èŠ‚ï¼Œå¤§ç«¯åºï¼‰
            view.setUint32(0, totalLength, false);
            
            // å†™å…¥æ¶ˆæ¯IDï¼ˆ2å­—èŠ‚ï¼Œå¤§ç«¯åºï¼‰
            view.setUint16(4, msgId, false);
            
            // å†™å…¥protobufæ•°æ®
            bytes.set(protoData, 6);
            
            return buffer;
        }
        
        // Varintç¼–ç 
        function encodeVarint(value) {
            const bytes = [];
            while (value > 0x7f) {
                bytes.push((value & 0x7f) | 0x80);
                value >>>= 7;
            }
            bytes.push(value & 0x7f);
            return bytes;
        }

        function sendMessage(buffer) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('WebSocket æœªè¿æ¥');
                return;
            }
            
            try {
                ws.send(buffer);
                sentCount++;
                updateStats();
            } catch (error) {
                console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
                alert('å‘é€æ¶ˆæ¯å¤±è´¥: ' + error.message);
            }
        }

        function sendEnterRoom() {
            const buffer = encodeProtobufMessage(1901);
            sendMessage(buffer);
            addSentMessage('ğŸ“¤ [Protobuf] è¿›å…¥æˆ¿é—´ (1901) - type: 1');
        }

        function sendStartGame(betAmount) {
            const buffer = encodeProtobufMessage(1902, {betAmount: betAmount});
            sendMessage(buffer);
            addSentMessage(`ğŸ“¤ [Protobuf] å¼€å§‹æ¸¸æˆ (1902) - ä¸‹æ³¨: ${betAmount}`);
        }

        function updateStatus(connected) {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            
            if (connected) {
                indicator.classList.add('connected');
                text.textContent = 'å·²è¿æ¥';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
            } else {
                indicator.classList.remove('connected');
                text.textContent = 'æœªè¿æ¥';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
            }
        }

        function addSentMessage(message) {
            const container = document.getElementById('sentMessages');
            const messageDiv = createMessageDiv(message, 'sent');
            container.insertBefore(messageDiv, container.firstChild);
        }

        function addReceivedMessage(message, type = 'received', isHtml = false) {
            const container = document.getElementById('receivedMessages');
            const messageDiv = createMessageDiv(message, type === 'error' ? 'error' : 'received', isHtml);
            container.insertBefore(messageDiv, container.firstChild);
        }

        function createMessageDiv(message, className, isHtml = false) {
            const div = document.createElement('div');
            div.className = `message ${className}`;
            
            const timestamp = new Date().toLocaleTimeString();
            if (isHtml) {
                div.innerHTML = `
                    <span class="timestamp">${timestamp}</span>
                    <div class="content">${message}</div>
                `;
            } else {
                div.innerHTML = `
                    <span class="timestamp">${timestamp}</span>
                    <span class="content">${escapeHtml(message)}</span>
                `;
            }
            
            return div;
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return String(text).replace(/[&<>"']/g, m => map[m]);
        }

        function clearLogs() {
            document.getElementById('sentMessages').innerHTML = '';
            document.getElementById('receivedMessages').innerHTML = '';
            sentCount = 0;
            receivedCount = 0;
            errorCount = 0;
            updateStats();
        }
    </script>
</body>
</html>