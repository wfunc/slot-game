# ACM消息分片问题修复说明

## 问题描述
ACM设备发送的大型JSON响应在接收时被分片成多个数据库记录，导致JSON解析失败。

### 问题表现
- 单个JSON消息被分割成多个serial_logs记录
- 每个片段作为独立消息处理，导致JSON解析失败
- 数据库中出现大量不完整的JSON片段

### 根本原因
原有的`readLoop`实现按换行符分割消息，将每一行视为独立消息。但ACM协议的JSON响应是多行格式，并使用`\nend\n>`作为消息终止符。

## 解决方案

### 修复内容
1. **消息缓冲机制**
   - 添加专门的JSON消息缓冲区`jsonBuffer`
   - 使用`inJSONMessage`标志跟踪JSON消息状态

2. **消息边界识别**
   - 识别JSON消息开始：`{"`
   - 识别JSON消息结束：`\nend\n>`序列
   - 累积所有片段直到找到完整的终止符

3. **完整消息处理**
   - 只有在接收到完整消息后才进行处理
   - 只记录完整消息到数据库，避免片段记录

### 代码改动
文件：`internal/hardware/acm_controller.go`
函数：`readLoop()`

主要改动：
- 添加JSON消息缓冲区和状态标志
- 实现基于`\nend\n>`终止符的消息边界检测
- 分别处理普通消息和JSON消息
- 确保只有完整的消息才被处理和记录

## 测试建议

1. **验证消息完整性**
   ```bash
   # 查看数据库中的ACM消息是否完整
   sqlite3 data/slot-game.db "SELECT id, created_at, raw_data FROM serial_logs WHERE device_type='ACM_RECEIVE' ORDER BY id DESC LIMIT 5"
   ```

2. **检查JSON解析**
   - 确认大型JSON响应能够正确解析
   - 验证消息不再被分片存储

3. **性能测试**
   - 验证缓冲机制不会造成内存泄漏
   - 确认消息处理延迟在可接受范围内

## 注意事项

1. **消息格式假设**
   - 假设ACM的JSON消息总是以`{"`开始
   - 假设消息总是以`\nend\n>`结束
   - 如果协议格式变化，需要相应调整

2. **缓冲区管理**
   - 当前实现没有缓冲区大小限制
   - 如果收到异常大的消息，可能需要添加保护机制

3. **向后兼容性**
   - 修改保持了对普通（非JSON）消息的兼容性
   - 单行消息仍然能够正确处理

## 后续优化建议

1. **添加缓冲区大小限制**
   ```go
   const maxJSONBufferSize = 1024 * 1024 // 1MB
   if len(jsonBuffer) > maxJSONBufferSize {
       // 重置缓冲区，记录错误
   }
   ```

2. **添加超时机制**
   - 如果JSON消息长时间未完成，自动重置

3. **改进错误处理**
   - 更详细的错误日志
   - 消息解析失败的恢复机制

4. **协议版本支持**
   - 支持不同版本的ACM协议
   - 可配置的消息终止符